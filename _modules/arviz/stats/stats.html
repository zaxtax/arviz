
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>arviz.stats.stats &#8212; ArviZ dev documentation</title>
    
  <link href="../../../_static/css/theme.css" rel="stylesheet">
  <link href="../../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-codeautolink.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.59c74d8c95b765a7fd995ac71d459ebe.min.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/design-tabs.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-W1G68W77YV"></script>
<script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){ dataLayer.push(arguments); }
                    gtag('js', new Date());
                    gtag('config', 'G-W1G68W77YV');
                </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../../../index.html">
  <img src="../../../_static/logo.png" class="logo" alt="logo">
</a>


    
    dev
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../getting_started/index.html">
  Getting Started
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../examples/index.html">
  Example Gallery
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../user_guide/index.html">
  User Guide
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api/index.html">
  API Reference
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../community.html">
  Community
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../contributing/index.html">
  Contributing
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../about_us.html">
  About us
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/arviz-devs/arviz" rel="noopener" target="_blank" title="GitHub">
            <span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label>
          </a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/arviz_devs" rel="noopener" target="_blank" title="Twitter">
            <span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label>
          </a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
  
    
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          
  


          
  
    
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
          </div>
          
  


          
  
    
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for arviz.stats.stats</h1><div class="highlight"><pre>
<span></span><span class="c1"># pylint: disable=too-many-lines</span>
<span class="sd">&quot;&quot;&quot;Statistical functions in ArviZ.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">Callable</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">st</span>
<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="n">NO_GET_ARGS</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">get_args</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">NO_GET_ARGS</span> <span class="o">=</span> <span class="kc">True</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">_log</span>
<span class="kn">from</span> <span class="nn">..data</span> <span class="kn">import</span> <span class="n">InferenceData</span><span class="p">,</span> <span class="n">convert_to_dataset</span><span class="p">,</span> <span class="n">convert_to_inference_data</span>
<span class="kn">from</span> <span class="nn">..rcparams</span> <span class="kn">import</span> <span class="n">rcParams</span><span class="p">,</span> <span class="n">ScaleKeyword</span><span class="p">,</span> <span class="n">ICKeyword</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">Numba</span><span class="p">,</span> <span class="n">_numba_var</span><span class="p">,</span> <span class="n">_var_names</span><span class="p">,</span> <span class="n">get_coords</span>
<span class="kn">from</span> <span class="nn">.density_utils</span> <span class="kn">import</span> <span class="n">get_bins</span> <span class="k">as</span> <span class="n">_get_bins</span>
<span class="kn">from</span> <span class="nn">.density_utils</span> <span class="kn">import</span> <span class="n">histogram</span> <span class="k">as</span> <span class="n">_histogram</span>
<span class="kn">from</span> <span class="nn">.density_utils</span> <span class="kn">import</span> <span class="n">kde</span> <span class="k">as</span> <span class="n">_kde</span>
<span class="kn">from</span> <span class="nn">.diagnostics</span> <span class="kn">import</span> <span class="n">_mc_error</span><span class="p">,</span> <span class="n">_multichain_statistics</span><span class="p">,</span> <span class="n">ess</span>
<span class="kn">from</span> <span class="nn">.stats_utils</span> <span class="kn">import</span> <span class="n">ELPDData</span><span class="p">,</span> <span class="n">_circular_standard_deviation</span><span class="p">,</span> <span class="n">smooth_data</span>
<span class="kn">from</span> <span class="nn">.stats_utils</span> <span class="kn">import</span> <span class="n">get_log_likelihood</span> <span class="k">as</span> <span class="n">_get_log_likelihood</span>
<span class="kn">from</span> <span class="nn">.stats_utils</span> <span class="kn">import</span> <span class="n">logsumexp</span> <span class="k">as</span> <span class="n">_logsumexp</span>
<span class="kn">from</span> <span class="nn">.stats_utils</span> <span class="kn">import</span> <span class="n">make_ufunc</span> <span class="k">as</span> <span class="n">_make_ufunc</span>
<span class="kn">from</span> <span class="nn">.stats_utils</span> <span class="kn">import</span> <span class="n">stats_variance_2d</span> <span class="k">as</span> <span class="n">svar</span>
<span class="kn">from</span> <span class="nn">.stats_utils</span> <span class="kn">import</span> <span class="n">wrap_xarray_ufunc</span> <span class="k">as</span> <span class="n">_wrap_xarray_ufunc</span>
<span class="kn">from</span> <span class="nn">..sel_utils</span> <span class="kn">import</span> <span class="n">xarray_var_iter</span>
<span class="kn">from</span> <span class="nn">..labels</span> <span class="kn">import</span> <span class="n">BaseLabeller</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;apply_test_function&quot;</span><span class="p">,</span>
    <span class="s2">&quot;compare&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hdi&quot;</span><span class="p">,</span>
    <span class="s2">&quot;loo&quot;</span><span class="p">,</span>
    <span class="s2">&quot;loo_pit&quot;</span><span class="p">,</span>
    <span class="s2">&quot;psislw&quot;</span><span class="p">,</span>
    <span class="s2">&quot;r2_score&quot;</span><span class="p">,</span>
    <span class="s2">&quot;summary&quot;</span><span class="p">,</span>
    <span class="s2">&quot;waic&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="compare"><a class="viewcode-back" href="../../../api/generated/arviz.compare.html#arviz.compare">[docs]</a><span class="k">def</span> <span class="nf">compare</span><span class="p">(</span>
    <span class="n">dataset_dict</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">InferenceData</span><span class="p">],</span>
    <span class="n">ic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ICKeyword</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;stacking&quot;</span><span class="p">,</span> <span class="s2">&quot;BB-pseudo-BMA&quot;</span><span class="p">,</span> <span class="s2">&quot;pseudo-MA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;stacking&quot;</span><span class="p">,</span>
    <span class="n">b_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ScaleKeyword</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">var_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compare models based on PSIS-LOO `loo` or WAIC `waic` cross-validation.</span>

<span class="sd">    LOO is leave-one-out (PSIS-LOO `loo`) cross-validation and</span>
<span class="sd">    WAIC is the widely applicable information criterion.</span>
<span class="sd">    Read more theory here - in a paper by some of the leading authorities</span>
<span class="sd">    on model selection dx.doi.org/10.1111/1467-9868.00353</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset_dict: dict[str] -&gt; InferenceData</span>
<span class="sd">        A dictionary of model names and :class:`arviz.InferenceData` objects</span>
<span class="sd">    ic: str, optional</span>
<span class="sd">        Information Criterion (PSIS-LOO `loo` or WAIC `waic`) used to compare models. Defaults to</span>
<span class="sd">        ``rcParams[&quot;stats.information_criterion&quot;]``.</span>
<span class="sd">    method: str, optional</span>
<span class="sd">        Method used to estimate the weights for each model. Available options are:</span>

<span class="sd">        - &#39;stacking&#39; : stacking of predictive distributions.</span>
<span class="sd">        - &#39;BB-pseudo-BMA&#39; : pseudo-Bayesian Model averaging using Akaike-type</span>
<span class="sd">          weighting. The weights are stabilized using the Bayesian bootstrap.</span>
<span class="sd">        - &#39;pseudo-BMA&#39;: pseudo-Bayesian Model averaging using Akaike-type</span>
<span class="sd">          weighting, without Bootstrap stabilization (not recommended).</span>

<span class="sd">        For more information read https://arxiv.org/abs/1704.02030</span>
<span class="sd">    b_samples: int, optional default = 1000</span>
<span class="sd">        Number of samples taken by the Bayesian bootstrap estimation.</span>
<span class="sd">        Only useful when method = &#39;BB-pseudo-BMA&#39;.</span>
<span class="sd">        Defaults to ``rcParams[&quot;stats.ic_compare_method&quot;]``.</span>
<span class="sd">    alpha: float, optional</span>
<span class="sd">        The shape parameter in the Dirichlet distribution used for the Bayesian bootstrap. Only</span>
<span class="sd">        useful when method = &#39;BB-pseudo-BMA&#39;. When alpha=1 (default), the distribution is uniform</span>
<span class="sd">        on the simplex. A smaller alpha will keeps the final weights more away from 0 and 1.</span>
<span class="sd">    seed: int or np.random.RandomState instance, optional</span>
<span class="sd">        If int or RandomState, use it for seeding Bayesian bootstrap. Only</span>
<span class="sd">        useful when method = &#39;BB-pseudo-BMA&#39;. Default None the global</span>
<span class="sd">        :mod:`numpy.random` state is used.</span>
<span class="sd">    scale: str, optional</span>
<span class="sd">        Output scale for IC. Available options are:</span>

<span class="sd">        - `log` : (default) log-score (after Vehtari et al. (2017))</span>
<span class="sd">        - `negative_log` : -1 * (log-score)</span>
<span class="sd">        - `deviance` : -2 * (log-score)</span>

<span class="sd">        A higher log-score (or a lower deviance) indicates a model with better predictive</span>
<span class="sd">        accuracy.</span>
<span class="sd">    var_name: str, optional</span>
<span class="sd">        If there is more than a single observed variable in the ``InferenceData``, which</span>
<span class="sd">        should be used as the basis for comparison.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A DataFrame, ordered from best to worst model (measured by information criteria).</span>
<span class="sd">    The index reflects the key with which the models are passed to this function. The columns are:</span>
<span class="sd">    rank: The rank-order of the models. 0 is the best.</span>
<span class="sd">    IC: Information Criteria (PSIS-LOO `loo` or WAIC `waic`).</span>
<span class="sd">        Higher IC indicates higher out-of-sample predictive fit (&quot;better&quot; model). Default LOO.</span>
<span class="sd">        If `scale` is `deviance` or `negative_log` smaller IC indicates</span>
<span class="sd">        higher out-of-sample predictive fit (&quot;better&quot; model).</span>
<span class="sd">    pIC: Estimated effective number of parameters.</span>
<span class="sd">    dIC: Relative difference between each IC (PSIS-LOO `loo` or WAIC `waic`)</span>
<span class="sd">          and the lowest IC (PSIS-LOO `loo` or WAIC `waic`).</span>
<span class="sd">          The top-ranked model is always 0.</span>
<span class="sd">    weight: Relative weight for each model.</span>
<span class="sd">        This can be loosely interpreted as the probability of each model (among the compared model)</span>
<span class="sd">        given the data. By default the uncertainty in the weights estimation is considered using</span>
<span class="sd">        Bayesian bootstrap.</span>
<span class="sd">    SE: Standard error of the IC estimate.</span>
<span class="sd">        If method = BB-pseudo-BMA these values are estimated using Bayesian bootstrap.</span>
<span class="sd">    dSE: Standard error of the difference in IC between each model and the top-ranked model.</span>
<span class="sd">        It&#39;s always 0 for the top-ranked model.</span>
<span class="sd">    warning: A value of 1 indicates that the computation of the IC may not be reliable.</span>
<span class="sd">        This could be indication of WAIC/LOO starting to fail see</span>
<span class="sd">        http://arxiv.org/abs/1507.04544 for details.</span>
<span class="sd">    scale: Scale used for the IC.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compare the centered and non centered models of the eight school problem:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data1 = az.load_arviz_data(&quot;non_centered_eight&quot;)</span>
<span class="sd">           ...: data2 = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">           ...: compare_dict = {&quot;non centered&quot;: data1, &quot;centered&quot;: data2}</span>
<span class="sd">           ...: az.compare(compare_dict)</span>

<span class="sd">    Compare the models using LOO-CV, returning the IC in log scale and calculating the</span>
<span class="sd">    weights using the stacking method.</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: az.compare(compare_dict, ic=&quot;loo&quot;, method=&quot;stacking&quot;, scale=&quot;log&quot;)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    loo : Compute the Pareto Smoothed importance sampling Leave One Out cross-validation.</span>
<span class="sd">    waic : Compute the widely applicable information criterion.</span>
<span class="sd">    plot_compare : Summary plot for model comparison.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Vehtari, A., Gelman, A. &amp; Gabry, J. Practical Bayesian model evaluation using</span>
<span class="sd">        leave-one-out cross-validation and WAIC. Stat Comput 27, 1413–1432 (2017)</span>
<span class="sd">        see https://doi.org/10.1007/s11222-016-9696-4</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataset_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ScaleKeyword</span><span class="p">,</span> <span class="n">scale</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ScaleKeyword</span><span class="p">,</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;stats.ic_scale&quot;</span><span class="p">])</span>
    <span class="n">allowable</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="s2">&quot;negative_log&quot;</span><span class="p">,</span> <span class="s2">&quot;deviance&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">NO_GET_ARGS</span> <span class="k">else</span> <span class="n">get_args</span><span class="p">(</span><span class="n">ScaleKeyword</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scale</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowable</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2"> is not a valid value for scale: must be in </span><span class="si">{</span><span class="n">allowable</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">ascending</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;negative_log&quot;</span><span class="p">:</span>
            <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">ascending</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">ic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ICKeyword</span><span class="p">,</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;stats.information_criterion&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ICKeyword</span><span class="p">,</span> <span class="n">ic</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
    <span class="n">allowable</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;loo&quot;</span><span class="p">,</span> <span class="s2">&quot;waic&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">NO_GET_ARGS</span> <span class="k">else</span> <span class="n">get_args</span><span class="p">(</span><span class="n">ICKeyword</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ic</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowable</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ic</span><span class="si">}</span><span class="s2"> is not a valid value for ic: must be in </span><span class="si">{</span><span class="n">allowable</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ic</span> <span class="o">==</span> <span class="s2">&quot;loo&quot;</span><span class="p">:</span>
        <span class="n">ic_func</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">loo</span>
        <span class="n">df_comp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;rank&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loo&quot;</span><span class="p">,</span>
                <span class="s2">&quot;p_loo&quot;</span><span class="p">,</span>
                <span class="s2">&quot;d_loo&quot;</span><span class="p">,</span>
                <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
                <span class="s2">&quot;se&quot;</span><span class="p">,</span>
                <span class="s2">&quot;dse&quot;</span><span class="p">,</span>
                <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loo_scale&quot;</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">scale_col</span> <span class="o">=</span> <span class="s2">&quot;loo_scale&quot;</span>
    <span class="k">elif</span> <span class="n">ic</span> <span class="o">==</span> <span class="s2">&quot;waic&quot;</span><span class="p">:</span>
        <span class="n">ic_func</span> <span class="o">=</span> <span class="n">waic</span>
        <span class="n">df_comp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;rank&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;p_waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;d_waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
                <span class="s2">&quot;se&quot;</span><span class="p">,</span>
                <span class="s2">&quot;dse&quot;</span><span class="p">,</span>
                <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_scale&quot;</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">scale_col</span> <span class="o">=</span> <span class="s2">&quot;waic_scale&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The information criterion </span><span class="si">{</span><span class="n">ic</span><span class="si">}</span><span class="s2"> is not supported.&quot;</span><span class="p">)</span>

    <span class="n">method</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;stats.ic_compare_method&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">method</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;stacking&quot;</span><span class="p">,</span> <span class="s2">&quot;bb-pseudo-bma&quot;</span><span class="p">,</span> <span class="s2">&quot;pseudo-bma&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">, to compute weights, is not supported.&quot;</span><span class="p">)</span>

    <span class="n">ic_se</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ic</span><span class="si">}</span><span class="s2">_se&quot;</span>
    <span class="n">p_ic</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;p_</span><span class="si">{</span><span class="n">ic</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">ic_i</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ic</span><span class="si">}</span><span class="s2">_i&quot;</span>

    <span class="n">ics</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">dataset_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Here is where the IC function is actually computed -- the rest of this</span>
            <span class="c1"># function is argument processing and return value formatting</span>
            <span class="n">ics</span> <span class="o">=</span> <span class="n">ics</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ic_func</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">pointwise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">)])</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Encountered error trying to compute </span><span class="si">{</span><span class="n">ic</span><span class="si">}</span><span class="s2"> from model </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="n">ics</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">names</span>
    <span class="n">ics</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">ic</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>
    <span class="n">ics</span><span class="p">[</span><span class="n">ic_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ics</span><span class="p">[</span><span class="n">ic_i</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;stacking&quot;</span><span class="p">:</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ic_i_val</span> <span class="o">=</span> <span class="n">_ic_matrix</span><span class="p">(</span><span class="n">ics</span><span class="p">,</span> <span class="n">ic_i</span><span class="p">)</span>
        <span class="n">exp_ic_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">ic_i_val</span> <span class="o">/</span> <span class="n">scale_value</span><span class="p">)</span>
        <span class="n">km1</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">def</span> <span class="nf">w_fuller</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">weights</span><span class="p">,</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)]))</span>

        <span class="k">def</span> <span class="nf">log_score</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">w_full</span> <span class="o">=</span> <span class="n">w_fuller</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                <span class="n">score</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exp_ic_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w_full</span><span class="p">))</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">score</span>

        <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
            <span class="n">w_full</span> <span class="o">=</span> <span class="n">w_fuller</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">km1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">km1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                    <span class="n">grad</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">exp_ic_i</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">exp_ic_i</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">km1</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">exp_ic_i</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w_full</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">grad</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">km1</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">cols</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">km1</span><span class="p">)]</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ineq&quot;</span><span class="p">,</span> <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">},</span>
            <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;ineq&quot;</span><span class="p">,</span> <span class="s2">&quot;fun&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">},</span>
        <span class="p">]</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
            <span class="n">fun</span><span class="o">=</span><span class="n">log_score</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">gradient</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span>
        <span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">w_fuller</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
        <span class="n">ses</span> <span class="o">=</span> <span class="n">ics</span><span class="p">[</span><span class="n">ic_se</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;bb-pseudo-bma&quot;</span><span class="p">:</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ic_i_val</span> <span class="o">=</span> <span class="n">_ic_matrix</span><span class="p">(</span><span class="n">ics</span><span class="p">,</span> <span class="n">ic_i</span><span class="p">)</span>
        <span class="n">ic_i_val</span> <span class="o">=</span> <span class="n">ic_i_val</span> <span class="o">*</span> <span class="n">rows</span>

        <span class="n">b_weighting</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">dirichlet</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">*</span> <span class="n">rows</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">b_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">b_samples</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="n">z_bs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b_samples</span><span class="p">):</span>
            <span class="n">z_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b_weighting</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ic_i_val</span><span class="p">)</span>
            <span class="n">u_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">z_b</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z_b</span><span class="p">))</span> <span class="o">/</span> <span class="n">scale_value</span><span class="p">)</span>
            <span class="n">z_bs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_b</span>  <span class="c1"># pylint: disable=unsupported-assignment-operation</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_weights</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u_weights</span><span class="p">)</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ses</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">z_bs</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>

    <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;pseudo-bma&quot;</span><span class="p">:</span>
        <span class="n">min_ic</span> <span class="o">=</span> <span class="n">ics</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ic</span><span class="p">]</span>
        <span class="n">z_rv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">ics</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_ic</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale_value</span><span class="p">)</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">z_rv</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z_rv</span><span class="p">)</span>
        <span class="n">ses</span> <span class="o">=</span> <span class="n">ics</span><span class="p">[</span><span class="n">ic_se</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="n">min_ic_i_val</span> <span class="o">=</span> <span class="n">ics</span><span class="p">[</span><span class="n">ic_i</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ics</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">ics</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">scale_value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">ic_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_ic_i_val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">min_ic_i_val</span> <span class="o">-</span> <span class="n">res</span><span class="p">[</span><span class="n">ic_i</span><span class="p">]</span>
            <span class="n">d_ic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
            <span class="n">d_std_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
            <span class="n">std_err</span> <span class="o">=</span> <span class="n">ses</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">val</span><span class="p">]</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">df_comp</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">idx</span><span class="p">,</span>
                <span class="n">res</span><span class="p">[</span><span class="n">ic</span><span class="p">],</span>
                <span class="n">res</span><span class="p">[</span><span class="n">p_ic</span><span class="p">],</span>
                <span class="n">d_ic</span><span class="p">,</span>
                <span class="n">weight</span><span class="p">,</span>
                <span class="n">std_err</span><span class="p">,</span>
                <span class="n">d_std_err</span><span class="p">,</span>
                <span class="n">res</span><span class="p">[</span><span class="s2">&quot;warning&quot;</span><span class="p">],</span>
                <span class="n">res</span><span class="p">[</span><span class="n">scale_col</span><span class="p">],</span>
            <span class="p">)</span>

    <span class="n">df_comp</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_comp</span><span class="p">[</span><span class="s2">&quot;rank&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">df_comp</span><span class="p">[</span><span class="s2">&quot;warning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_comp</span><span class="p">[</span><span class="s2">&quot;warning&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df_comp</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">ic</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_ic_matrix</span><span class="p">(</span><span class="n">ics</span><span class="p">,</span> <span class="n">ic_i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Store the previously computed pointwise predictive accuracy values (ics) in a 2D matrix.&quot;&quot;&quot;</span>
    <span class="n">cols</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ics</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ics</span><span class="p">[</span><span class="n">ic_i</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ic_i_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ics</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="n">ics</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">val</span><span class="p">][</span><span class="n">ic_i</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of observations should be the same across all models&quot;</span><span class="p">)</span>

        <span class="n">ic_i_val</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ic</span>

    <span class="k">return</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ic_i_val</span>


<div class="viewcode-block" id="hdi"><a class="viewcode-back" href="../../../api/generated/arviz.hdi.html#arviz.hdi">[docs]</a><span class="k">def</span> <span class="nf">hdi</span><span class="p">(</span>
    <span class="n">ary</span><span class="p">,</span>
    <span class="n">hdi_prob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">circular</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">multimodal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">group</span><span class="o">=</span><span class="s2">&quot;posterior&quot;</span><span class="p">,</span>
    <span class="n">var_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">filter_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">max_modes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">dask_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate highest density interval (HDI) of array for given probability.</span>

<span class="sd">    The HDI is the minimum width Bayesian credible interval (BCI).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ary: obj</span>
<span class="sd">        object containing posterior samples.</span>
<span class="sd">        Any object that can be converted to an :class:`arviz.InferenceData` object.</span>
<span class="sd">        Refer to documentation of :func:`arviz.convert_to_dataset` for details.</span>
<span class="sd">    hdi_prob: float, optional</span>
<span class="sd">        Prob for which the highest density interval will be computed. Defaults to</span>
<span class="sd">        ``stats.hdi_prob`` rcParam.</span>
<span class="sd">    circular: bool, optional</span>
<span class="sd">        Whether to compute the hdi taking into account `x` is a circular variable</span>
<span class="sd">        (in the range [-np.pi, np.pi]) or not. Defaults to False (i.e non-circular variables).</span>
<span class="sd">        Only works if multimodal is False.</span>
<span class="sd">    multimodal: bool, optional</span>
<span class="sd">        If true it may compute more than one hdi if the distribution is multimodal and the</span>
<span class="sd">        modes are well separated.</span>
<span class="sd">    skipna: bool, optional</span>
<span class="sd">        If true ignores nan values when computing the hdi. Defaults to false.</span>
<span class="sd">    group: str, optional</span>
<span class="sd">        Specifies which InferenceData group should be used to calculate hdi.</span>
<span class="sd">        Defaults to &#39;posterior&#39;</span>
<span class="sd">    var_names: list, optional</span>
<span class="sd">        Names of variables to include in the hdi report. Prefix the variables by ``~``</span>
<span class="sd">        when you want to exclude them from the report: `[&quot;~beta&quot;]` instead of `[&quot;beta&quot;]`</span>
<span class="sd">        (see :func:`arviz.summary` for more details).</span>
<span class="sd">    filter_vars: {None, &quot;like&quot;, &quot;regex&quot;}, optional, default=None</span>
<span class="sd">        If `None` (default), interpret var_names as the real variables names. If &quot;like&quot;,</span>
<span class="sd">        interpret var_names as substrings of the real variables names. If &quot;regex&quot;,</span>
<span class="sd">        interpret var_names as regular expressions on the real variables names. A la</span>
<span class="sd">        ``pandas.filter``.</span>
<span class="sd">    coords: mapping, optional</span>
<span class="sd">        Specifies the subset over to calculate hdi.</span>
<span class="sd">    max_modes: int, optional</span>
<span class="sd">        Specifies the maximum number of modes for multimodal case.</span>
<span class="sd">    dask_kwargs : dict, optional</span>
<span class="sd">        Dask related kwargs passed to :func:`~arviz.wrap_xarray_ufunc`.</span>
<span class="sd">    kwargs: dict, optional</span>
<span class="sd">        Additional keywords passed to :func:`~arviz.wrap_xarray_ufunc`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray or xarray.Dataset, depending upon input</span>
<span class="sd">        lower(s) and upper(s) values of the interval(s).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    plot_hdi : Plot highest density intervals for regression data.</span>
<span class="sd">    xarray.Dataset.quantile : Calculate quantiles of array for given probabilities.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Calculate the HDI of a Normal random variable:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: import numpy as np</span>
<span class="sd">           ...: data = np.random.normal(size=2000)</span>
<span class="sd">           ...: az.hdi(data, hdi_prob=.68)</span>

<span class="sd">    Calculate the HDI of a dataset:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data = az.load_arviz_data(&#39;centered_eight&#39;)</span>
<span class="sd">           ...: az.hdi(data)</span>

<span class="sd">    We can also calculate the HDI of some of the variables of dataset:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: az.hdi(data, var_names=[&quot;mu&quot;, &quot;theta&quot;])</span>

<span class="sd">    By default, ``hdi`` is calculated over the ``chain`` and ``draw`` dimensions. We can use the</span>
<span class="sd">    ``input_core_dims`` argument of :func:`~arviz.wrap_xarray_ufunc` to change this. In this example</span>
<span class="sd">    we calculate the HDI also over the ``school`` dimension:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: az.hdi(data, var_names=&quot;theta&quot;, input_core_dims = [[&quot;chain&quot;,&quot;draw&quot;, &quot;school&quot;]])</span>

<span class="sd">    We can also calculate the hdi over a particular selection:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: az.hdi(data, coords={&quot;chain&quot;:[0, 1, 3]}, input_core_dims = [[&quot;draw&quot;]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">hdi_prob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hdi_prob</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;stats.hdi_prob&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">hdi_prob</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The value of hdi_prob should be in the interval (0, 1]&quot;</span><span class="p">)</span>

    <span class="n">func_kwargs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;hdi_prob&quot;</span><span class="p">:</span> <span class="n">hdi_prob</span><span class="p">,</span>
        <span class="s2">&quot;skipna&quot;</span><span class="p">:</span> <span class="n">skipna</span><span class="p">,</span>
        <span class="s2">&quot;out_shape&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">max_modes</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">multimodal</span> <span class="k">else</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span>
    <span class="p">}</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;output_core_dims&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="s2">&quot;hdi&quot;</span><span class="p">,</span> <span class="s2">&quot;mode&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">multimodal</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;hdi&quot;</span><span class="p">]])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">multimodal</span><span class="p">:</span>
        <span class="n">func_kwargs</span><span class="p">[</span><span class="s2">&quot;circular&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">circular</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">func_kwargs</span><span class="p">[</span><span class="s2">&quot;max_modes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_modes</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">_hdi_multimodal</span> <span class="k">if</span> <span class="n">multimodal</span> <span class="k">else</span> <span class="n">_hdi</span>

    <span class="n">isarray</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isarray</span> <span class="ow">and</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">func_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;out_shape&quot;</span><span class="p">)</span>
        <span class="n">hdi_data</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="o">**</span><span class="n">func_kwargs</span><span class="p">)</span>  <span class="c1"># pylint: disable=unexpected-keyword-arg</span>
        <span class="k">return</span> <span class="n">hdi_data</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hdi_data</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="p">:]</span> <span class="k">if</span> <span class="n">multimodal</span> <span class="k">else</span> <span class="n">hdi_data</span>

    <span class="k">if</span> <span class="n">isarray</span> <span class="ow">and</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;hdi currently interprets 2d data as (draw, shape) but this will change in &quot;</span>
            <span class="s2">&quot;a future release to (chain, draw) for coherence with other functions&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">ary</span> <span class="o">=</span> <span class="n">convert_to_dataset</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="n">group</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ary</span> <span class="o">=</span> <span class="n">get_coords</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
    <span class="n">var_names</span> <span class="o">=</span> <span class="n">_var_names</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">filter_vars</span><span class="p">)</span>
    <span class="n">ary</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="n">var_names</span><span class="p">]</span> <span class="k">if</span> <span class="n">var_names</span> <span class="k">else</span> <span class="n">ary</span>

    <span class="n">hdi_coord</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">([</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;higher&quot;</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;hdi&quot;</span><span class="p">],</span> <span class="n">attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">hdi_prob</span><span class="o">=</span><span class="n">hdi_prob</span><span class="p">))</span>
    <span class="n">hdi_data</span> <span class="o">=</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">func_kwargs</span><span class="o">=</span><span class="n">func_kwargs</span><span class="p">,</span> <span class="n">dask_kwargs</span><span class="o">=</span><span class="n">dask_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s2">&quot;hdi&quot;</span><span class="p">:</span> <span class="n">hdi_coord</span><span class="p">})</span>
    <span class="n">hdi_data</span> <span class="o">=</span> <span class="n">hdi_data</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="s2">&quot;mode&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">multimodal</span> <span class="k">else</span> <span class="n">hdi_data</span>
    <span class="k">return</span> <span class="n">hdi_data</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">isarray</span> <span class="k">else</span> <span class="n">hdi_data</span></div>


<span class="k">def</span> <span class="nf">_hdi</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">hdi_prob</span><span class="p">,</span> <span class="n">circular</span><span class="p">,</span> <span class="n">skipna</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute hpi over the flattened array.&quot;&quot;&quot;</span>
    <span class="n">ary</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">skipna</span><span class="p">:</span>
        <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nans</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">ary</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="o">~</span><span class="n">nans</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">circular</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">circmean</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">ary</span> <span class="o">=</span> <span class="n">ary</span> <span class="o">-</span> <span class="n">mean</span>
        <span class="n">ary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ary</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ary</span><span class="p">))</span>

    <span class="n">ary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
    <span class="n">interval_idx_inc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">hdi_prob</span> <span class="o">*</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">n_intervals</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">interval_idx_inc</span>
    <span class="n">interval_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">ary</span><span class="p">[</span><span class="n">interval_idx_inc</span><span class="p">:],</span> <span class="n">ary</span><span class="p">[:</span><span class="n">n_intervals</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval_width</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too few elements for interval calculation. &quot;</span><span class="p">)</span>

    <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">interval_width</span><span class="p">)</span>
    <span class="n">hdi_min</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="n">min_idx</span><span class="p">]</span>
    <span class="n">hdi_max</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="n">min_idx</span> <span class="o">+</span> <span class="n">interval_idx_inc</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">circular</span><span class="p">:</span>
        <span class="n">hdi_min</span> <span class="o">=</span> <span class="n">hdi_min</span> <span class="o">+</span> <span class="n">mean</span>
        <span class="n">hdi_max</span> <span class="o">=</span> <span class="n">hdi_max</span> <span class="o">+</span> <span class="n">mean</span>
        <span class="n">hdi_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">hdi_min</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">hdi_min</span><span class="p">))</span>
        <span class="n">hdi_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">hdi_max</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">hdi_max</span><span class="p">))</span>

    <span class="n">hdi_interval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">hdi_min</span><span class="p">,</span> <span class="n">hdi_max</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">hdi_interval</span>


<span class="k">def</span> <span class="nf">_hdi_multimodal</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">hdi_prob</span><span class="p">,</span> <span class="n">skipna</span><span class="p">,</span> <span class="n">max_modes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute HDI if the distribution is multimodal.&quot;&quot;&quot;</span>
    <span class="n">ary</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">skipna</span><span class="p">:</span>
        <span class="n">ary</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ary</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
        <span class="n">bins</span><span class="p">,</span> <span class="n">density</span> <span class="o">=</span> <span class="n">_kde</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">range_x</span> <span class="o">=</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">range_x</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">density</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">_get_bins</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_histogram</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">density</span> <span class="o">*=</span> <span class="n">dx</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">density</span><span class="p">)</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">density</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">hdi_prob</span><span class="p">]</span>
    <span class="n">intervals</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="n">intervals_splitted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">dx</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">hdi_intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">max_modes</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">interval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">intervals_splitted</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">max_modes</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;found more modes than </span><span class="si">{</span><span class="n">max_modes</span><span class="si">}</span><span class="s2">, returning only the first </span><span class="si">{</span><span class="n">max_modes</span><span class="si">}</span><span class="s2"> modes&quot;</span>
            <span class="p">)</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">interval</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">hdi_intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hdi_intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">interval</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hdi_intervals</span><span class="p">)</span>


<div class="viewcode-block" id="loo"><a class="viewcode-back" href="../../../api/generated/arviz.loo.html#arviz.loo">[docs]</a><span class="k">def</span> <span class="nf">loo</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pointwise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute Pareto-smoothed importance sampling leave-one-out cross-validation (PSIS-LOO-CV).</span>

<span class="sd">    Estimates the expected log pointwise predictive density (elpd) using Pareto-smoothed</span>
<span class="sd">    importance sampling leave-one-out cross-validation (PSIS-LOO-CV). Also calculates LOO&#39;s</span>
<span class="sd">    standard error and the effective number of parameters. Read more theory here</span>
<span class="sd">    https://arxiv.org/abs/1507.04544 and here https://arxiv.org/abs/1507.02646</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: obj</span>
<span class="sd">        Any object that can be converted to an :class:`arviz.InferenceData` object.</span>
<span class="sd">        Refer to documentation of</span>
<span class="sd">        :func:`arviz.convert_to_dataset` for details.</span>
<span class="sd">    pointwise: bool, optional</span>
<span class="sd">        If True the pointwise predictive accuracy will be returned. Defaults to</span>
<span class="sd">        ``stats.ic_pointwise`` rcParam.</span>
<span class="sd">    var_name : str, optional</span>
<span class="sd">        The name of the variable in log_likelihood groups storing the pointwise log</span>
<span class="sd">        likelihood data to use for loo computation.</span>
<span class="sd">    reff: float, optional</span>
<span class="sd">        Relative MCMC efficiency, ``ess / n`` i.e. number of effective samples divided by the number</span>
<span class="sd">        of actual samples. Computed from trace by default.</span>
<span class="sd">    scale: str</span>
<span class="sd">        Output scale for loo. Available options are:</span>

<span class="sd">        - ``log`` : (default) log-score</span>
<span class="sd">        - ``negative_log`` : -1 * log-score</span>
<span class="sd">        - ``deviance`` : -2 * log-score</span>

<span class="sd">        A higher log-score (or a lower deviance or negative log_score) indicates a model with</span>
<span class="sd">        better predictive accuracy.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ELPDData object (inherits from :class:`pandas.Series`) with the following row/attributes:</span>
<span class="sd">    loo: approximated expected log pointwise predictive density (elpd)</span>
<span class="sd">    loo_se: standard error of loo</span>
<span class="sd">    p_loo: effective number of parameters</span>
<span class="sd">    shape_warn: bool</span>
<span class="sd">        True if the estimated shape parameter of</span>
<span class="sd">        Pareto distribution is greater than 0.7 for one or more samples</span>
<span class="sd">    loo_i: array of pointwise predictive accuracy, only if pointwise True</span>
<span class="sd">    pareto_k: array of Pareto shape values, only if pointwise True</span>
<span class="sd">    loo_scale: scale of the loo results</span>

<span class="sd">        The returned object has a custom print method that overrides pd.Series method.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    compare : Compare models based on PSIS-LOO loo or WAIC waic cross-validation.</span>
<span class="sd">    waic : Compute the widely applicable information criterion.</span>
<span class="sd">    plot_compare : Summary plot for model comparison.</span>
<span class="sd">    plot_elpd : Plot pointwise elpd differences between two or more models.</span>
<span class="sd">    plot_khat : Plot Pareto tail indices for diagnosing convergence.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Calculate LOO of a model:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">           ...: az.loo(data)</span>

<span class="sd">    Calculate LOO of a model and return the pointwise values:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [2]: data_loo = az.loo(data, pointwise=True)</span>
<span class="sd">           ...: data_loo.loo_i</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inference_data</span> <span class="o">=</span> <span class="n">convert_to_inference_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">_get_log_likelihood</span><span class="p">(</span><span class="n">inference_data</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">)</span>
    <span class="n">pointwise</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;stats.ic_pointwise&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">pointwise</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pointwise</span>

    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">__sample__</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">))</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_data_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;stats.ic_scale&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scale</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;deviance&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;negative_log&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Valid scale values are &quot;deviance&quot;, &quot;log&quot;, &quot;negative_log&quot;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">reff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inference_data</span><span class="p">,</span> <span class="s2">&quot;posterior&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Must be able to extract a posterior group from data.&quot;</span><span class="p">)</span>
        <span class="n">posterior</span> <span class="o">=</span> <span class="n">inference_data</span><span class="o">.</span><span class="n">posterior</span>
        <span class="n">n_chains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">posterior</span><span class="o">.</span><span class="n">chain</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_chains</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">reff</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ess_p</span> <span class="o">=</span> <span class="n">ess</span><span class="p">(</span><span class="n">posterior</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span>
            <span class="c1"># this mean is over all data variables</span>
            <span class="n">reff</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ess_p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ess_p</span><span class="o">.</span><span class="n">data_vars</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_samples</span>
            <span class="p">)</span>

    <span class="n">log_weights</span><span class="p">,</span> <span class="n">pareto_shape</span> <span class="o">=</span> <span class="n">psislw</span><span class="p">(</span><span class="o">-</span><span class="n">log_likelihood</span><span class="p">,</span> <span class="n">reff</span><span class="p">)</span>
    <span class="n">log_weights</span> <span class="o">+=</span> <span class="n">log_likelihood</span>

    <span class="n">warn_mg</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pareto_shape</span> <span class="o">&gt;</span> <span class="mf">0.7</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Estimated shape parameter of Pareto distribution is greater than 0.7 for &quot;</span>
            <span class="s2">&quot;one or more samples. You should consider using a more robust model, this is because &quot;</span>
            <span class="s2">&quot;importance sampling is less likely to work well if the marginal posterior and &quot;</span>
            <span class="s2">&quot;LOO posterior are very different. This is more likely to happen with a non-robust &quot;</span>
            <span class="s2">&quot;model and highly influential observations.&quot;</span>
        <span class="p">)</span>
        <span class="n">warn_mg</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">ufunc_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;n_dims&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;ravel&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;input_core_dims&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&quot;__sample__&quot;</span><span class="p">]]}</span>
    <span class="n">loo_lppd_i</span> <span class="o">=</span> <span class="n">scale_value</span> <span class="o">*</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
        <span class="n">_logsumexp</span><span class="p">,</span> <span class="n">log_weights</span><span class="p">,</span> <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
    <span class="n">loo_lppd</span> <span class="o">=</span> <span class="n">loo_lppd_i</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">loo_lppd_se</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_data_points</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">loo_lppd_i</span><span class="o">.</span><span class="n">values</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="n">lppd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
            <span class="n">_logsumexp</span><span class="p">,</span>
            <span class="n">log_likelihood</span><span class="p">,</span>
            <span class="n">func_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;b_inv&quot;</span><span class="p">:</span> <span class="n">n_samples</span><span class="p">},</span>
            <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="p">)</span>
    <span class="n">p_loo</span> <span class="o">=</span> <span class="n">lppd</span> <span class="o">-</span> <span class="n">loo_lppd</span> <span class="o">/</span> <span class="n">scale_value</span>

    <span class="k">if</span> <span class="n">pointwise</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">loo_lppd</span><span class="p">,</span> <span class="n">loo_lppd_i</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The point-wise LOO is the same with the sum LOO, please double check &quot;</span>
                <span class="s2">&quot;the Observed RV in your model to make sure it returns element-wise logp.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ELPDData</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span>
                <span class="n">loo_lppd</span><span class="p">,</span>
                <span class="n">loo_lppd_se</span><span class="p">,</span>
                <span class="n">p_loo</span><span class="p">,</span>
                <span class="n">n_samples</span><span class="p">,</span>
                <span class="n">n_data_points</span><span class="p">,</span>
                <span class="n">warn_mg</span><span class="p">,</span>
                <span class="n">loo_lppd_i</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;loo_i&quot;</span><span class="p">),</span>
                <span class="n">pareto_shape</span><span class="p">,</span>
                <span class="n">scale</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">index</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;loo&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loo_se&quot;</span><span class="p">,</span>
                <span class="s2">&quot;p_loo&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_samples&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_data_points&quot;</span><span class="p">,</span>
                <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loo_i&quot;</span><span class="p">,</span>
                <span class="s2">&quot;pareto_k&quot;</span><span class="p">,</span>
                <span class="s2">&quot;loo_scale&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ELPDData</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">loo_lppd</span><span class="p">,</span> <span class="n">loo_lppd_se</span><span class="p">,</span> <span class="n">p_loo</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_data_points</span><span class="p">,</span> <span class="n">warn_mg</span><span class="p">,</span> <span class="n">scale</span><span class="p">],</span>
            <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;loo&quot;</span><span class="p">,</span> <span class="s2">&quot;loo_se&quot;</span><span class="p">,</span> <span class="s2">&quot;p_loo&quot;</span><span class="p">,</span> <span class="s2">&quot;n_samples&quot;</span><span class="p">,</span> <span class="s2">&quot;n_data_points&quot;</span><span class="p">,</span> <span class="s2">&quot;warning&quot;</span><span class="p">,</span> <span class="s2">&quot;loo_scale&quot;</span><span class="p">],</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="psislw"><a class="viewcode-back" href="../../../api/generated/arviz.psislw.html#arviz.psislw">[docs]</a><span class="k">def</span> <span class="nf">psislw</span><span class="p">(</span><span class="n">log_weights</span><span class="p">,</span> <span class="n">reff</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pareto smoothed importance sampling (PSIS).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the ``log_weights`` input is an :class:`~xarray.DataArray` with a dimension</span>
<span class="sd">    named ``__sample__`` (recommended) ``psislw`` will interpret this dimension as samples,</span>
<span class="sd">    and all other dimensions as dimensions of the observed data, looping over them to</span>
<span class="sd">    calculate the psislw of each observation. If no ``__sample__`` dimension is present or</span>
<span class="sd">    the input is a numpy array, the last dimension will be interpreted as ``__sample__``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_weights: array</span>
<span class="sd">        Array of size (n_observations, n_samples)</span>
<span class="sd">    reff: float</span>
<span class="sd">        relative MCMC efficiency, ``ess / n``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lw_out: array</span>
<span class="sd">        Smoothed log weights</span>
<span class="sd">    kss: array</span>
<span class="sd">        Pareto tail indices</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    * Vehtari et al. (2015) see https://arxiv.org/abs/1507.02646</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    loo : Compute Pareto-smoothed importance sampling leave-one-out cross-validation (PSIS-LOO-CV).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get Pareto smoothed importance sampling (PSIS) log weights:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">           ...: log_likelihood = data.sample_stats.log_likelihood.stack(</span>
<span class="sd">           ...:     __sample__=(&quot;chain&quot;, &quot;draw&quot;)</span>
<span class="sd">           ...: )</span>
<span class="sd">           ...: az.psislw(-log_likelihood, reff=0.8)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">log_weights</span><span class="p">,</span> <span class="s2">&quot;__sample__&quot;</span><span class="p">):</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_weights</span><span class="o">.</span><span class="n">__sample__</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">size</span> <span class="k">for</span> <span class="n">size</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">log_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">log_weights</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="s2">&quot;__sample__&quot;</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">log_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">log_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># precalculate constants</span>
    <span class="n">cutoff_ind</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n_samples</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">/</span> <span class="n">reff</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">cutoffmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member, assignment-from-no-return</span>
    <span class="n">k_min</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">3</span>

    <span class="c1"># create output array with proper dimensions</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">log_weights</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">)])</span>

    <span class="c1"># define kwargs</span>
    <span class="n">func_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;cutoff_ind&quot;</span><span class="p">:</span> <span class="n">cutoff_ind</span><span class="p">,</span> <span class="s2">&quot;cutoffmin&quot;</span><span class="p">:</span> <span class="n">cutoffmin</span><span class="p">,</span> <span class="s2">&quot;k_min&quot;</span><span class="p">:</span> <span class="n">k_min</span><span class="p">,</span> <span class="s2">&quot;out&quot;</span><span class="p">:</span> <span class="n">out</span><span class="p">}</span>
    <span class="n">ufunc_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;n_dims&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;n_output&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;ravel&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;check_shape&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;input_core_dims&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&quot;__sample__&quot;</span><span class="p">]],</span> <span class="s2">&quot;output_core_dims&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&quot;__sample__&quot;</span><span class="p">],</span> <span class="p">[]]}</span>
    <span class="n">log_weights</span><span class="p">,</span> <span class="n">pareto_shape</span> <span class="o">=</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
        <span class="n">_psislw</span><span class="p">,</span>
        <span class="n">log_weights</span><span class="p">,</span>
        <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span>
        <span class="n">func_kwargs</span><span class="o">=</span><span class="n">func_kwargs</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">log_weights</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="n">log_weights</span> <span class="o">=</span> <span class="n">log_weights</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;log_weights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pareto_shape</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="n">pareto_shape</span> <span class="o">=</span> <span class="n">pareto_shape</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;pareto_shape&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">log_weights</span><span class="p">,</span> <span class="n">pareto_shape</span></div>


<span class="k">def</span> <span class="nf">_psislw</span><span class="p">(</span><span class="n">log_weights</span><span class="p">,</span> <span class="n">cutoff_ind</span><span class="p">,</span> <span class="n">cutoffmin</span><span class="p">,</span> <span class="n">k_min</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pareto smoothed importance sampling (PSIS) for a 1D vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    log_weights: array</span>
<span class="sd">        Array of length n_observations</span>
<span class="sd">    cutoff_ind: int</span>
<span class="sd">    cutoffmin: float</span>
<span class="sd">    k_min: float</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lw_out: array</span>
<span class="sd">        Smoothed log weights</span>
<span class="sd">    kss: float</span>
<span class="sd">        Pareto tail index</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">log_weights</span><span class="p">)</span>

    <span class="c1"># improve numerical accuracy</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># sort the array</span>
    <span class="n">x_sort_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># divide log weights into body and right tail</span>
    <span class="n">xcutoff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">x_sort_ind</span><span class="p">[</span><span class="n">cutoff_ind</span><span class="p">]],</span> <span class="n">cutoffmin</span><span class="p">)</span>

    <span class="n">expxcutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">xcutoff</span><span class="p">)</span>
    <span class="p">(</span><span class="n">tailinds</span><span class="p">,)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">xcutoff</span><span class="p">)</span>  <span class="c1"># pylint: disable=unbalanced-tuple-unpacking</span>
    <span class="n">x_tail</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">tailinds</span><span class="p">]</span>
    <span class="n">tail_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_tail</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tail_len</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># not enough tail samples for gpdfit</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># order of tail samples</span>
        <span class="n">x_tail_si</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x_tail</span><span class="p">)</span>
        <span class="c1"># fit generalized Pareto distribution to the right tail samples</span>
        <span class="n">x_tail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x_tail</span><span class="p">)</span> <span class="o">-</span> <span class="n">expxcutoff</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">_gpdfit</span><span class="p">(</span><span class="n">x_tail</span><span class="p">[</span><span class="n">x_tail_si</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">k_min</span><span class="p">:</span>
            <span class="c1"># no smoothing if short tail or GPD fit failed</span>
            <span class="c1"># compute ordered statistic for the fit</span>
            <span class="n">sti</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">tail_len</span><span class="p">)</span> <span class="o">/</span> <span class="n">tail_len</span>
            <span class="n">smoothed_tail</span> <span class="o">=</span> <span class="n">_gpinv</span><span class="p">(</span><span class="n">sti</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="n">smoothed_tail</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>  <span class="c1"># pylint: disable=assignment-from-no-return</span>
                <span class="n">smoothed_tail</span> <span class="o">+</span> <span class="n">expxcutoff</span>
            <span class="p">)</span>
            <span class="c1"># place the smoothed tail into the output array</span>
            <span class="n">x</span><span class="p">[</span><span class="n">tailinds</span><span class="p">[</span><span class="n">x_tail_si</span><span class="p">]]</span> <span class="o">=</span> <span class="n">smoothed_tail</span>
            <span class="c1"># truncate smoothed values to the largest raw weight 0</span>
            <span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># renormalize weights</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">_logsumexp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span>


<span class="k">def</span> <span class="nf">_gpdfit</span><span class="p">(</span><span class="n">ary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimate the parameters for the Generalized Pareto Distribution (GPD).</span>

<span class="sd">    Empirical Bayes estimate for the parameters of the generalized Pareto</span>
<span class="sd">    distribution given the data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ary: array</span>
<span class="sd">        sorted 1D data array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    k: float</span>
<span class="sd">        estimated shape parameter</span>
<span class="sd">    sigma: float</span>
<span class="sd">        estimated scale parameter</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prior_bs</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">prior_k</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
    <span class="n">m_est</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="n">b_ary</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m_est</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m_est</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="n">b_ary</span> <span class="o">/=</span> <span class="n">prior_bs</span> <span class="o">*</span> <span class="n">ary</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">b_ary</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ary</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">k_ary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">b_ary</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ary</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># pylint: disable=no-member</span>
    <span class="n">len_scale</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b_ary</span> <span class="o">/</span> <span class="n">k_ary</span><span class="p">))</span> <span class="o">-</span> <span class="n">k_ary</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">len_scale</span> <span class="o">-</span> <span class="n">len_scale</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># remove negligible weights</span>
    <span class="n">real_idxs</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">real_idxs</span><span class="p">):</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">real_idxs</span><span class="p">]</span>
        <span class="n">b_ary</span> <span class="o">=</span> <span class="n">b_ary</span><span class="p">[</span><span class="n">real_idxs</span><span class="p">]</span>
    <span class="c1"># normalise weights</span>
    <span class="n">weights</span> <span class="o">/=</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># posterior mean for b</span>
    <span class="n">b_post</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b_ary</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span>
    <span class="c1"># estimate for k</span>
    <span class="n">k_post</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">b_post</span> <span class="o">*</span> <span class="n">ary</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># pylint: disable=invalid-unary-operand-type,no-member</span>
    <span class="c1"># add prior for k_post</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="o">-</span><span class="n">k_post</span> <span class="o">/</span> <span class="n">b_post</span>
    <span class="n">k_post</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">k_post</span> <span class="o">+</span> <span class="n">prior_k</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">prior_k</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">k_post</span><span class="p">,</span> <span class="n">sigma</span>


<span class="k">def</span> <span class="nf">_gpinv</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Inverse Generalized Pareto distribution function.&quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=unsupported-assignment-operation, invalid-unary-operand-type</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigma</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">probs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">probs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ok</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">probs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="o">-</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">probs</span><span class="p">))</span> <span class="o">/</span> <span class="n">kappa</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">sigma</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">probs</span><span class="p">[</span><span class="n">ok</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="o">-</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="o">-</span><span class="n">probs</span><span class="p">[</span><span class="n">ok</span><span class="p">]))</span> <span class="o">/</span> <span class="n">kappa</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">sigma</span>
        <span class="n">x</span><span class="p">[</span><span class="n">probs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">kappa</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">probs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="p">[</span><span class="n">probs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sigma</span> <span class="o">/</span> <span class="n">kappa</span>
    <span class="k">return</span> <span class="n">x</span>


<div class="viewcode-block" id="r2_score"><a class="viewcode-back" href="../../../api/generated/arviz.r2_score.html#arviz.r2_score">[docs]</a><span class="k">def</span> <span class="nf">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;R² for Bayesian regression models. Only valid for linear models.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y_true: array-like of shape = (n_samples) or (n_samples, n_outputs)</span>
<span class="sd">        Ground truth (correct) target values.</span>
<span class="sd">    y_pred: array-like of shape = (n_samples) or (n_samples, n_outputs)</span>
<span class="sd">        Estimated target values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pandas Series with the following indices:</span>
<span class="sd">    r2: Bayesian R²</span>
<span class="sd">    r2_std: standard deviation of the Bayesian R².</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    plot_lm : Posterior predictive and mean plots for regression-like data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Calculate R² for Bayesian regression models :</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data = az.load_arviz_data(&#39;regression1d&#39;)</span>
<span class="sd">           ...: y_true = data.observed_data[&quot;y&quot;].values</span>
<span class="sd">           ...: y_pred = data.posterior_predictive.stack(sample=(&quot;chain&quot;, &quot;draw&quot;))[&quot;y&quot;].values.T</span>
<span class="sd">           ...: az.r2_score(y_true, y_pred)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_numba_flag</span> <span class="o">=</span> <span class="n">Numba</span><span class="o">.</span><span class="n">numba_flag</span>
    <span class="k">if</span> <span class="n">y_pred</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">var_y_est</span> <span class="o">=</span> <span class="n">_numba_var</span><span class="p">(</span><span class="n">svar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
        <span class="n">var_e</span> <span class="o">=</span> <span class="n">_numba_var</span><span class="p">(</span><span class="n">svar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">var_y_est</span> <span class="o">=</span> <span class="n">_numba_var</span><span class="p">(</span><span class="n">svar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">y_pred</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">var_e</span> <span class="o">=</span> <span class="n">_numba_var</span><span class="p">(</span><span class="n">svar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="p">(</span><span class="n">y_true</span> <span class="o">-</span> <span class="n">y_pred</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">r_squared</span> <span class="o">=</span> <span class="n">var_y_est</span> <span class="o">/</span> <span class="p">(</span><span class="n">var_y_est</span> <span class="o">+</span> <span class="n">var_e</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r_squared</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">r_squared</span><span class="p">)],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;r2&quot;</span><span class="p">,</span> <span class="s2">&quot;r2_std&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="summary"><a class="viewcode-back" href="../../../api/generated/arviz.summary.html#arviz.summary">[docs]</a><span class="k">def</span> <span class="nf">summary</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">var_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">filter_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fmt</span><span class="p">:</span> <span class="s2">&quot;Literal[&#39;wide&#39;, &#39;long&#39;, &#39;xarray&#39;]&quot;</span> <span class="o">=</span> <span class="s2">&quot;wide&quot;</span><span class="p">,</span>
    <span class="n">kind</span><span class="p">:</span> <span class="s2">&quot;Literal[&#39;all&#39;, &#39;stats&#39;, &#39;diagnostics&#39;]&quot;</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="n">round_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">circ_var_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">stat_funcs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">extend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">hdi_prob</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">labeller</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">index_origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Create a data frame with summary statistics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: obj</span>
<span class="sd">        Any object that can be converted to an :class:`arviz.InferenceData` object</span>
<span class="sd">        Refer to documentation of :func:`arviz.convert_to_dataset` for details</span>
<span class="sd">    var_names: list</span>
<span class="sd">        Names of variables to include in summary. Prefix the variables by ``~`` when you</span>
<span class="sd">        want to exclude them from the summary: `[&quot;~beta&quot;]` instead of `[&quot;beta&quot;]` (see</span>
<span class="sd">        examples below).</span>
<span class="sd">    filter_vars: {None, &quot;like&quot;, &quot;regex&quot;}, optional, default=None</span>
<span class="sd">        If `None` (default), interpret var_names as the real variables names. If &quot;like&quot;,</span>
<span class="sd">        interpret var_names as substrings of the real variables names. If &quot;regex&quot;,</span>
<span class="sd">        interpret var_names as regular expressions on the real variables names. A la</span>
<span class="sd">        ``pandas.filter``.</span>
<span class="sd">    coords: Dict[str, List[Any]], optional</span>
<span class="sd">        Coordinate subset for which to calculate the summary.</span>
<span class="sd">    group: str</span>
<span class="sd">        Select a group for summary. Defaults to &quot;posterior&quot;, &quot;prior&quot; or first group</span>
<span class="sd">        in that order, depending what groups exists.</span>
<span class="sd">    fmt: {&#39;wide&#39;, &#39;long&#39;, &#39;xarray&#39;}</span>
<span class="sd">        Return format is either pandas.DataFrame {&#39;wide&#39;, &#39;long&#39;} or xarray.Dataset {&#39;xarray&#39;}.</span>
<span class="sd">    kind: {&#39;all&#39;, &#39;stats&#39;, &#39;diagnostics&#39;}</span>
<span class="sd">        Whether to include the `stats`: `mean`, `sd`, `hdi_3%`, `hdi_97%`, or the `diagnostics`:</span>
<span class="sd">        `mcse_mean`, `mcse_sd`, `ess_bulk`, `ess_tail`, and `r_hat`. Default to include `all` of</span>
<span class="sd">        them.</span>
<span class="sd">    round_to: int</span>
<span class="sd">        Number of decimals used to round results. Defaults to 2. Use &quot;none&quot; to return raw numbers.</span>
<span class="sd">    circ_var_names: list</span>
<span class="sd">        A list of circular variables to compute circular stats for</span>
<span class="sd">    stat_funcs: dict</span>
<span class="sd">        A list of functions or a dict of functions with function names as keys used to calculate</span>
<span class="sd">        statistics. By default, the mean, standard deviation, simulation standard error, and</span>
<span class="sd">        highest posterior density intervals are included.</span>

<span class="sd">        The functions will be given one argument, the samples for a variable as an nD array,</span>
<span class="sd">        The functions should be in the style of a ufunc and return a single number. For example,</span>
<span class="sd">        :func:`numpy.mean`, or ``scipy.stats.var`` would both work.</span>
<span class="sd">    extend: boolean</span>
<span class="sd">        If True, use the statistics returned by ``stat_funcs`` in addition to, rather than in place</span>
<span class="sd">        of, the default statistics. This is only meaningful when ``stat_funcs`` is not None.</span>
<span class="sd">    hdi_prob: float, optional</span>
<span class="sd">        Highest density interval to compute. Defaults to 0.94. This is only meaningful when</span>
<span class="sd">        ``stat_funcs`` is None.</span>
<span class="sd">    skipna: bool</span>
<span class="sd">        If true ignores nan values when computing the summary statistics, it does not affect the</span>
<span class="sd">        behaviour of the functions passed to ``stat_funcs``. Defaults to false.</span>
<span class="sd">    labeller : labeller instance, optional</span>
<span class="sd">        Class providing the method `make_label_flat` to generate the labels in the plot titles.</span>
<span class="sd">        For more details on ``labeller`` usage see :ref:`label_guide`</span>
<span class="sd">    credible_interval: float, optional</span>
<span class="sd">        deprecated: Please see hdi_prob</span>
<span class="sd">    order</span>
<span class="sd">        deprecated: order is now ignored.</span>
<span class="sd">    index_origin</span>
<span class="sd">        deprecated: index_origin is now ignored, modify the coordinate values to change the</span>
<span class="sd">        value used in summary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame or xarray.Dataset</span>
<span class="sd">        Return type dicated by `fmt` argument.</span>
<span class="sd">        Return value will contain summary statistics for each variable. Default statistics are:</span>
<span class="sd">        `mean`, `sd`, `hdi_3%`, `hdi_97%`, `mcse_mean`, `mcse_sd`, `ess_bulk`, `ess_tail`, and</span>
<span class="sd">        `r_hat`.</span>
<span class="sd">        `r_hat` is only computed for traces with 2 or more chains.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    waic : Compute the widely applicable information criterion.</span>
<span class="sd">    loo : Compute Pareto-smoothed importance sampling leave-one-out</span>
<span class="sd">          cross-validation (PSIS-LOO-CV).</span>
<span class="sd">    ess : Calculate estimate of the effective sample size (ess).</span>
<span class="sd">    rhat : Compute estimate of rank normalized splitR-hat for a set of traces.</span>
<span class="sd">    mcse : Calculate Markov Chain Standard Error statistic.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">           ...: az.summary(data, var_names=[&quot;mu&quot;, &quot;tau&quot;])</span>

<span class="sd">    You can use ``filter_vars`` to select variables without having to specify all the exact</span>
<span class="sd">    names. Use ``filter_vars=&quot;like&quot;`` to select based on partial naming:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: az.summary(data, var_names=[&quot;the&quot;], filter_vars=&quot;like&quot;)</span>

<span class="sd">    Use ``filter_vars=&quot;regex&quot;`` to select based on regular expressions, and prefix the variables</span>
<span class="sd">    you want to exclude by ``~``. Here, we exclude from the summary all the variables</span>
<span class="sd">    starting with the letter t:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: az.summary(data, var_names=[&quot;~^t&quot;], filter_vars=&quot;regex&quot;)</span>

<span class="sd">    Other statistics can be calculated by passing a list of functions</span>
<span class="sd">    or a dictionary with key, function pairs.</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import numpy as np</span>
<span class="sd">           ...: def median_sd(x):</span>
<span class="sd">           ...:     median = np.percentile(x, 50)</span>
<span class="sd">           ...:     sd = np.sqrt(np.mean((x-median)**2))</span>
<span class="sd">           ...:     return sd</span>
<span class="sd">           ...:</span>
<span class="sd">           ...: func_dict = {</span>
<span class="sd">           ...:     &quot;std&quot;: np.std,</span>
<span class="sd">           ...:     &quot;median_std&quot;: median_sd,</span>
<span class="sd">           ...:     &quot;5%&quot;: lambda x: np.percentile(x, 5),</span>
<span class="sd">           ...:     &quot;median&quot;: lambda x: np.percentile(x, 50),</span>
<span class="sd">           ...:     &quot;95%&quot;: lambda x: np.percentile(x, 95),</span>
<span class="sd">           ...: }</span>
<span class="sd">           ...: az.summary(</span>
<span class="sd">           ...:     data,</span>
<span class="sd">           ...:     var_names=[&quot;mu&quot;, &quot;tau&quot;],</span>
<span class="sd">           ...:     stat_funcs=func_dict,</span>
<span class="sd">           ...:     extend=False</span>
<span class="sd">           ...: )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_log</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">index_origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;index_origin has been deprecated. summary now shows coordinate values, &quot;</span>
            <span class="s2">&quot;to change the label shown, modify the coordinate values before calling summary&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">index_origin</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;data.index_origin&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">labeller</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">labeller</span> <span class="o">=</span> <span class="n">BaseLabeller</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">hdi_prob</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">hdi_prob</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;stats.hdi_prob&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">hdi_prob</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The value of hdi_prob should be in the interval (0, 1]&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">InferenceData</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">groups</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;InferenceData does not contain any groups&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;posterior&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;posterior&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="s2">&quot;prior&quot;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;prior&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Selecting first found group: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">groups</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;InferenceData does not contain group: </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">group</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">convert_to_dataset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;posterior&quot;</span><span class="p">)</span>
    <span class="n">var_names</span> <span class="o">=</span> <span class="n">_var_names</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">filter_vars</span><span class="p">)</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span> <span class="k">if</span> <span class="n">var_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dataset</span><span class="p">[</span><span class="n">var_names</span><span class="p">]</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">get_coords</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>

    <span class="n">fmt_group</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;wide&quot;</span><span class="p">,</span> <span class="s2">&quot;long&quot;</span><span class="p">,</span> <span class="s2">&quot;xarray&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fmt_group</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid format: &#39;</span><span class="si">{</span><span class="n">fmt</span><span class="si">}</span><span class="s2">&#39;. Formatting options are: </span><span class="si">{</span><span class="n">fmt_group</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">kind_group</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;stats&quot;</span><span class="p">,</span> <span class="s2">&quot;diagnostics&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kind_group</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid kind: &#39;</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s2">&#39;. Kind options are: </span><span class="si">{</span><span class="n">kind_group</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;order has been deprecated. summary now shows coordinate values.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span>
        <span class="p">)</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">hdi_prob</span>

    <span class="n">extra_metrics</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">extra_metric_names</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">stat_funcs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stat_funcs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">stat_func_name</span><span class="p">,</span> <span class="n">stat_func</span> <span class="ow">in</span> <span class="n">stat_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">extra_metrics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                        <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">stat_func</span><span class="p">),</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">extra_metric_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat_func_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">stat_func</span> <span class="ow">in</span> <span class="n">stat_funcs</span><span class="p">:</span>
                <span class="n">extra_metrics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                        <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">stat_func</span><span class="p">),</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">extra_metric_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat_func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">extend</span> <span class="ow">and</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;stats&quot;</span><span class="p">]:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

        <span class="n">sd</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

        <span class="n">hdi_post</span> <span class="o">=</span> <span class="n">hdi</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">hdi_prob</span><span class="o">=</span><span class="n">hdi_prob</span><span class="p">,</span> <span class="n">multimodal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="n">hdi_lower</span> <span class="o">=</span> <span class="n">hdi_post</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">hdi</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">hdi_higher</span> <span class="o">=</span> <span class="n">hdi_post</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">hdi</span><span class="o">=</span><span class="s2">&quot;higher&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">circ_var_names</span><span class="p">:</span>
        <span class="n">nan_policy</span> <span class="o">=</span> <span class="s2">&quot;omit&quot;</span> <span class="k">if</span> <span class="n">skipna</span> <span class="k">else</span> <span class="s2">&quot;propagate&quot;</span>
        <span class="n">circ_mean</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">circmean</span><span class="p">),</span>
            <span class="n">dataset</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="n">nan_policy</span><span class="p">),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),),</span>
        <span class="p">)</span>
        <span class="n">_numba_flag</span> <span class="o">=</span> <span class="n">Numba</span><span class="o">.</span><span class="n">numba_flag</span>
        <span class="n">func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">_numba_flag</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">_circular_standard_deviation</span>
            <span class="n">kwargs_circ_std</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">circstd</span>
            <span class="n">kwargs_circ_std</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">low</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">nan_policy</span><span class="o">=</span><span class="n">nan_policy</span><span class="p">)</span>
        <span class="n">circ_sd</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
            <span class="n">dataset</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs_circ_std</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),),</span>
        <span class="p">)</span>

        <span class="n">circ_mcse</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">_mc_error</span><span class="p">),</span>
            <span class="n">dataset</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">circular</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),),</span>
        <span class="p">)</span>

        <span class="n">circ_hdi</span> <span class="o">=</span> <span class="n">hdi</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">hdi_prob</span><span class="o">=</span><span class="n">hdi_prob</span><span class="p">,</span> <span class="n">circular</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="n">circ_hdi_lower</span> <span class="o">=</span> <span class="n">circ_hdi</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">hdi</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">circ_hdi_higher</span> <span class="o">=</span> <span class="n">circ_hdi</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">hdi</span><span class="o">=</span><span class="s2">&quot;higher&quot;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;diagnostics&quot;</span><span class="p">]:</span>
        <span class="n">mcse_mean</span><span class="p">,</span> <span class="n">mcse_sd</span><span class="p">,</span> <span class="n">ess_bulk</span><span class="p">,</span> <span class="n">ess_tail</span><span class="p">,</span> <span class="n">r_hat</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
            <span class="n">_make_ufunc</span><span class="p">(</span><span class="n">_multichain_statistics</span><span class="p">,</span> <span class="n">n_output</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">ravel</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">dataset</span><span class="p">,</span>
            <span class="n">input_core_dims</span><span class="o">=</span><span class="p">((</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">),),</span>
            <span class="n">output_core_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">([]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)),</span>
        <span class="p">)</span>

    <span class="c1"># Combine metrics</span>
    <span class="n">metrics</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">metric_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">extend</span><span class="p">:</span>
        <span class="n">metrics_</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="n">metrics_names_</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sd&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;hdi_</span><span class="si">{</span><span class="mi">100</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;hdi_</span><span class="si">{</span><span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mcse_mean&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mcse_sd&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ess_bulk&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ess_tail&quot;</span><span class="p">,</span>
            <span class="s2">&quot;r_hat&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">metrics_</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">mean</span><span class="p">,</span>
                <span class="n">sd</span><span class="p">,</span>
                <span class="n">hdi_lower</span><span class="p">,</span>
                <span class="n">hdi_higher</span><span class="p">,</span>
                <span class="n">mcse_mean</span><span class="p">,</span>
                <span class="n">mcse_sd</span><span class="p">,</span>
                <span class="n">ess_bulk</span><span class="p">,</span>
                <span class="n">ess_tail</span><span class="p">,</span>
                <span class="n">r_hat</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;stats&quot;</span><span class="p">:</span>
            <span class="n">metrics_</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean</span><span class="p">,</span> <span class="n">sd</span><span class="p">,</span> <span class="n">hdi_lower</span><span class="p">,</span> <span class="n">hdi_higher</span><span class="p">)</span>
            <span class="n">metrics_names_</span> <span class="o">=</span> <span class="n">metrics_names_</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;diagnostics&quot;</span><span class="p">:</span>
            <span class="n">metrics_</span> <span class="o">=</span> <span class="p">(</span><span class="n">mcse_mean</span><span class="p">,</span> <span class="n">mcse_sd</span><span class="p">,</span> <span class="n">ess_bulk</span><span class="p">,</span> <span class="n">ess_tail</span><span class="p">,</span> <span class="n">r_hat</span><span class="p">)</span>
            <span class="n">metrics_names_</span> <span class="o">=</span> <span class="n">metrics_names_</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        <span class="n">metrics</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">metrics_</span><span class="p">)</span>
        <span class="n">metric_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">metrics_names_</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">circ_var_names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">!=</span> <span class="s2">&quot;diagnostics&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">metric</span><span class="p">,</span> <span class="n">circ_stat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="c1"># Replace only the first 5 statistics for their circular equivalent</span>
                <span class="n">metrics</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span>
                <span class="p">(</span><span class="n">circ_mean</span><span class="p">,</span> <span class="n">circ_sd</span><span class="p">,</span> <span class="n">circ_hdi_lower</span><span class="p">,</span> <span class="n">circ_hdi_higher</span><span class="p">,</span> <span class="n">circ_mcse</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="k">for</span> <span class="n">circ_var</span> <span class="ow">in</span> <span class="n">circ_var_names</span><span class="p">:</span>
                    <span class="n">metric</span><span class="p">[</span><span class="n">circ_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">circ_stat</span><span class="p">[</span><span class="n">circ_var</span><span class="p">]</span>

    <span class="n">metrics</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra_metrics</span><span class="p">)</span>
    <span class="n">metric_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra_metric_names</span><span class="p">)</span>
    <span class="n">joined</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;metric&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric_names</span><span class="p">)</span><span class="o">.</span><span class="n">reset_coords</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">n_metrics</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric_names</span><span class="p">)</span>
    <span class="n">n_vars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">joined</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="n">n_metrics</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">joined</span><span class="o">.</span><span class="n">data_vars</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;wide&quot;</span><span class="p">:</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">n_vars</span><span class="p">),</span> <span class="n">n_metrics</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)),</span> <span class="n">columns</span><span class="o">=</span><span class="n">metric_names</span>
        <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">isel</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="n">xarray_var_iter</span><span class="p">(</span><span class="n">joined</span><span class="p">,</span> <span class="n">skip_dims</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;metric&quot;</span><span class="p">})</span>
        <span class="p">):</span>
            <span class="n">summary_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labeller</span><span class="o">.</span><span class="n">make_label_flat</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">sel</span><span class="p">,</span> <span class="n">isel</span><span class="p">))</span>
        <span class="n">summary_df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">indices</span>
    <span class="k">elif</span> <span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;long&quot;</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">joined</span><span class="o">.</span><span class="n">to_dataframe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;metric&quot;</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># format is &#39;xarray&#39;</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">joined</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">round_to</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">round_to</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">)):</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">summary_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">round_to</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">round_to</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;None&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;long&quot;</span><span class="p">,</span> <span class="s2">&quot;wide&quot;</span><span class="p">)):</span>
        <span class="c1"># Don&#39;t round xarray object by default (even with &quot;none&quot;)</span>
        <span class="n">decimals</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">col</span><span class="p">:</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;ess_bulk&quot;</span><span class="p">,</span> <span class="s2">&quot;ess_tail&quot;</span><span class="p">,</span> <span class="s2">&quot;r_hat&quot;</span><span class="p">}</span> <span class="k">else</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="s2">&quot;r_hat&quot;</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">summary_df</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">}</span>
        <span class="n">summary_df</span> <span class="o">=</span> <span class="n">summary_df</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">summary_df</span></div>


<div class="viewcode-block" id="waic"><a class="viewcode-back" href="../../../api/generated/arviz.waic.html#arviz.waic">[docs]</a><span class="k">def</span> <span class="nf">waic</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pointwise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dask_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the widely applicable information criterion.</span>

<span class="sd">    Estimates the expected log pointwise predictive density (elpd) using WAIC. Also calculates the</span>
<span class="sd">    WAIC&#39;s standard error and the effective number of parameters.</span>
<span class="sd">    Read more theory here https://arxiv.org/abs/1507.04544 and here https://arxiv.org/abs/1004.2316</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: obj</span>
<span class="sd">        Any object that can be converted to an :class:`arviz.InferenceData` object.</span>
<span class="sd">        Refer to documentation of :func:`arviz.convert_to_inference_data` for details.</span>
<span class="sd">    pointwise: bool</span>
<span class="sd">        If True the pointwise predictive accuracy will be returned. Defaults to</span>
<span class="sd">        ``stats.ic_pointwise`` rcParam.</span>
<span class="sd">    var_name : str, optional</span>
<span class="sd">        The name of the variable in log_likelihood groups storing the pointwise log</span>
<span class="sd">        likelihood data to use for waic computation.</span>
<span class="sd">    scale: str</span>
<span class="sd">        Output scale for WAIC. Available options are:</span>

<span class="sd">        - `log` : (default) log-score</span>
<span class="sd">        - `negative_log` : -1 * log-score</span>
<span class="sd">        - `deviance` : -2 * log-score</span>

<span class="sd">        A higher log-score (or a lower deviance or negative log_score) indicates a model with</span>
<span class="sd">        better predictive accuracy.</span>
<span class="sd">    dask_kwargs : dict, optional</span>
<span class="sd">        Dask related kwargs passed to :func:`~arviz.wrap_xarray_ufunc`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ELPDData object (inherits from :class:`pandas.Series`) with the following row/attributes:</span>
<span class="sd">    waic: approximated expected log pointwise predictive density (elpd)</span>
<span class="sd">    waic_se: standard error of waic</span>
<span class="sd">    p_waic: effective number parameters</span>
<span class="sd">    var_warn: bool</span>
<span class="sd">        True if posterior variance of the log predictive densities exceeds 0.4</span>
<span class="sd">    waic_i: :class:`~xarray.DataArray` with the pointwise predictive accuracy,</span>
<span class="sd">            only if pointwise=True</span>
<span class="sd">    waic_scale: scale of the reported waic results</span>

<span class="sd">        The returned object has a custom print method that overrides pd.Series method.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    loo : Compute Pareto-smoothed importance sampling leave-one-out cross-validation (PSIS-LOO-CV).</span>
<span class="sd">    compare : Compare models based on PSIS-LOO-CV or WAIC.</span>
<span class="sd">    plot_compare : Summary plot for model comparison.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Calculate WAIC of a model:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">           ...: az.waic(data)</span>

<span class="sd">    Calculate WAIC of a model and return the pointwise values:</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [2]: data_waic = az.waic(data, pointwise=True)</span>
<span class="sd">           ...: data_waic.waic_i</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inference_data</span> <span class="o">=</span> <span class="n">convert_to_inference_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">_get_log_likelihood</span><span class="p">(</span><span class="n">inference_data</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">)</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;stats.ic_scale&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">scale</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">pointwise</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;stats.ic_pointwise&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">pointwise</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pointwise</span>

    <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;deviance&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;log&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s2">&quot;negative_log&quot;</span><span class="p">:</span>
        <span class="n">scale_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Valid scale values are &quot;deviance&quot;, &quot;log&quot;, &quot;negative_log&quot;&#39;</span><span class="p">)</span>

    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">__sample__</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">))</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_data_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">ufunc_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;n_dims&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;ravel&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;input_core_dims&quot;</span><span class="p">:</span> <span class="p">[[</span><span class="s2">&quot;__sample__&quot;</span><span class="p">]]}</span>
    <span class="n">lppd_i</span> <span class="o">=</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
        <span class="n">_logsumexp</span><span class="p">,</span>
        <span class="n">log_likelihood</span><span class="p">,</span>
        <span class="n">func_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;b_inv&quot;</span><span class="p">:</span> <span class="n">n_samples</span><span class="p">},</span>
        <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span>
        <span class="n">dask_kwargs</span><span class="o">=</span><span class="n">dask_kwargs</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">vars_lpd</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;__sample__&quot;</span><span class="p">)</span>
    <span class="n">warn_mg</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">vars_lpd</span> <span class="o">&gt;</span> <span class="mf">0.4</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;For one or more samples the posterior variance of the log predictive &quot;</span>
                <span class="s2">&quot;densities exceeds 0.4. This could be indication of WAIC starting to fail. </span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;See http://arxiv.org/abs/1507.04544 for details&quot;</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">warn_mg</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">waic_i</span> <span class="o">=</span> <span class="n">scale_value</span> <span class="o">*</span> <span class="p">(</span><span class="n">lppd_i</span> <span class="o">-</span> <span class="n">vars_lpd</span><span class="p">)</span>
    <span class="n">waic_se</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_data_points</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">waic_i</span><span class="o">.</span><span class="n">values</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="n">waic_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">waic_i</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">p_waic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vars_lpd</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pointwise</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">waic_sum</span><span class="p">,</span> <span class="n">waic_i</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>  <span class="c1"># pylint: disable=no-member</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sd">&quot;&quot;&quot;The point-wise WAIC is the same with the sum WAIC, please double check</span>
<span class="sd">            the Observed RV in your model to make sure it returns element-wise logp.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ELPDData</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span>
                <span class="n">waic_sum</span><span class="p">,</span>
                <span class="n">waic_se</span><span class="p">,</span>
                <span class="n">p_waic</span><span class="p">,</span>
                <span class="n">n_samples</span><span class="p">,</span>
                <span class="n">n_data_points</span><span class="p">,</span>
                <span class="n">warn_mg</span><span class="p">,</span>
                <span class="n">waic_i</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;waic_i&quot;</span><span class="p">),</span>
                <span class="n">scale</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="n">index</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_se&quot;</span><span class="p">,</span>
                <span class="s2">&quot;p_waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_samples&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_data_points&quot;</span><span class="p">,</span>
                <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_i&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_scale&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ELPDData</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">waic_sum</span><span class="p">,</span> <span class="n">waic_se</span><span class="p">,</span> <span class="n">p_waic</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_data_points</span><span class="p">,</span> <span class="n">warn_mg</span><span class="p">,</span> <span class="n">scale</span><span class="p">],</span>
            <span class="n">index</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_se&quot;</span><span class="p">,</span>
                <span class="s2">&quot;p_waic&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_samples&quot;</span><span class="p">,</span>
                <span class="s2">&quot;n_data_points&quot;</span><span class="p">,</span>
                <span class="s2">&quot;warning&quot;</span><span class="p">,</span>
                <span class="s2">&quot;waic_scale&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="loo_pit"><a class="viewcode-back" href="../../../api/generated/arviz.loo_pit.html#arviz.loo_pit">[docs]</a><span class="k">def</span> <span class="nf">loo_pit</span><span class="p">(</span><span class="n">idata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_hat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute leave one out (PSIS-LOO) probability integral transform (PIT) values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    idata: InferenceData</span>
<span class="sd">        :class:`arviz.InferenceData` object.</span>
<span class="sd">    y: array, DataArray or str</span>
<span class="sd">        Observed data. If str, ``idata`` must be present and contain the observed data group</span>
<span class="sd">    y_hat: array, DataArray or str</span>
<span class="sd">        Posterior predictive samples for ``y``. It must have the same shape as y plus an</span>
<span class="sd">        extra dimension at the end of size n_samples (chains and draws stacked). If str or</span>
<span class="sd">        None, ``idata`` must contain the posterior predictive group. If None, y_hat is taken</span>
<span class="sd">        equal to y, thus, y must be str too.</span>
<span class="sd">    log_weights: array or DataArray</span>
<span class="sd">        Smoothed log_weights. It must have the same shape as ``y_hat``</span>
<span class="sd">    dask_kwargs : dict, optional</span>
<span class="sd">        Dask related kwargs passed to :func:`~arviz.wrap_xarray_ufunc`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    loo_pit: array or DataArray</span>
<span class="sd">        Value of the LOO-PIT at each observed data point.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    plot_loo_pit : Plot Leave-One-Out probability integral transformation (PIT) predictive checks.</span>
<span class="sd">    loo : Compute Pareto-smoothed importance sampling leave-one-out</span>
<span class="sd">          cross-validation (PSIS-LOO-CV).</span>
<span class="sd">    plot_elpd : Plot pointwise elpd differences between two or more models.</span>
<span class="sd">    plot_khat : Plot Pareto tail indices for diagnosing convergence.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Calculate LOO-PIT values using as test quantity the observed values themselves.</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: import arviz as az</span>
<span class="sd">           ...: data = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">           ...: az.loo_pit(idata=data, y=&quot;obs&quot;)</span>

<span class="sd">    Calculate LOO-PIT values using as test quantity the square of the difference between</span>
<span class="sd">    each observation and `mu`. Both ``y`` and ``y_hat`` inputs will be array-like,</span>
<span class="sd">    but ``idata`` will still be passed in order to calculate the ``log_weights`` from</span>
<span class="sd">    there.</span>

<span class="sd">    .. ipython::</span>

<span class="sd">        In [1]: T = data.observed_data.obs - data.posterior.mu.median(dim=(&quot;chain&quot;, &quot;draw&quot;))</span>
<span class="sd">           ...: T_hat = data.posterior_predictive.obs - data.posterior.mu</span>
<span class="sd">           ...: T_hat = T_hat.stack(__sample__=(&quot;chain&quot;, &quot;draw&quot;))</span>
<span class="sd">           ...: az.loo_pit(idata=data, y=T**2, y_hat=T_hat**2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">if</span> <span class="n">idata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idata</span><span class="p">,</span> <span class="n">InferenceData</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;idata must be of type InferenceData or None&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">idata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">))</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">log_weights</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;all 3 y, y_hat and log_weights must be array or DataArray when idata is None &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but they are of types </span><span class="si">{</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">log_weights</span><span class="p">)]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y_hat</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">y_hat</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="n">y_hat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y_hat cannot be None if y is not a str&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">y_str</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">idata</span><span class="o">.</span><span class="n">observed_data</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;y must be of types array, DataArray or str, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_hat</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">y_hat</span> <span class="o">=</span> <span class="n">idata</span><span class="o">.</span><span class="n">posterior_predictive</span><span class="p">[</span><span class="n">y_hat</span><span class="p">]</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">__sample__</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_hat</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;y_hat must be of types array, DataArray or str, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">y_hat</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">log_weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">y_str</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">_get_log_likelihood</span><span class="p">(</span><span class="n">idata</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="n">y_str</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">_get_log_likelihood</span><span class="p">(</span><span class="n">idata</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">_get_log_likelihood</span><span class="p">(</span><span class="n">idata</span><span class="p">)</span>
            <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">log_likelihood</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">__sample__</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;chain&quot;</span><span class="p">,</span> <span class="s2">&quot;draw&quot;</span><span class="p">))</span>
            <span class="n">posterior</span> <span class="o">=</span> <span class="n">convert_to_dataset</span><span class="p">(</span><span class="n">idata</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;posterior&quot;</span><span class="p">)</span>
            <span class="n">n_chains</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">posterior</span><span class="o">.</span><span class="n">chain</span><span class="p">)</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_likelihood</span><span class="o">.</span><span class="n">__sample__</span><span class="p">)</span>
            <span class="n">ess_p</span> <span class="o">=</span> <span class="n">ess</span><span class="p">(</span><span class="n">posterior</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">)</span>
            <span class="c1"># this mean is over all data variables</span>
            <span class="n">reff</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">ess_p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ess_p</span><span class="o">.</span><span class="n">data_vars</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_samples</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n_chains</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="k">else</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">log_weights</span> <span class="o">=</span> <span class="n">psislw</span><span class="p">(</span><span class="o">-</span><span class="n">log_likelihood</span><span class="p">,</span> <span class="n">reff</span><span class="o">=</span><span class="n">reff</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">log_weights</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;log_weights must be None or of types array or DataArray, not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">log_weights</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_hat</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;y_hat must have 1 more dimension than y, but y_hat has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2"> dims and y has &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">y_hat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2"> dims&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y_hat</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;y has shape: </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> which should be equal to y_hat shape (omitting the last &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;dimension): </span><span class="si">{</span><span class="n">y_hat</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">y_hat</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">log_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;y_hat and log_weights must have the same shape but have shapes &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">y_hat</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">log_weights</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;input_core_dims&quot;</span><span class="p">:</span> <span class="p">[[],</span> <span class="p">[</span><span class="s2">&quot;__sample__&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;__sample__&quot;</span><span class="p">]],</span>
        <span class="s2">&quot;output_core_dims&quot;</span><span class="p">:</span> <span class="p">[[]],</span>
        <span class="s2">&quot;join&quot;</span><span class="p">:</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">ufunc_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;n_dims&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span> <span class="ow">or</span> <span class="n">y_hat</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">y_hat</span> <span class="o">=</span> <span class="n">smooth_data</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
        <span class="n">_loo_pit</span><span class="p">,</span>
        <span class="n">y</span><span class="p">,</span>
        <span class="n">y_hat</span><span class="p">,</span>
        <span class="n">log_weights</span><span class="p">,</span>
        <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_loo_pit</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">log_weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute LOO-PIT values.&quot;&quot;&quot;</span>
    <span class="n">sel</span> <span class="o">=</span> <span class="n">y_hat</span> <span class="o">&lt;=</span> <span class="n">y</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">_logsumexp</span><span class="p">(</span><span class="n">log_weights</span><span class="p">[</span><span class="n">sel</span><span class="p">]))</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>


<div class="viewcode-block" id="apply_test_function"><a class="viewcode-back" href="../../../api/generated/arviz.apply_test_function.html#arviz.apply_test_function">[docs]</a><span class="k">def</span> <span class="nf">apply_test_function</span><span class="p">(</span>
    <span class="n">idata</span><span class="p">,</span>
    <span class="n">func</span><span class="p">,</span>
    <span class="n">group</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
    <span class="n">var_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">pointwise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">out_data_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">out_pp_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">out_name_data</span><span class="o">=</span><span class="s2">&quot;T&quot;</span><span class="p">,</span>
    <span class="n">out_name_pp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">func_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">func_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">wrap_data_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">wrap_pp_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">overwrite</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a Bayesian test function to an InferenceData object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    idata: InferenceData</span>
<span class="sd">        :class:`arviz.InferenceData` object on which to apply the test function.</span>
<span class="sd">        This function will add new variables to the InferenceData object</span>
<span class="sd">        to store the result without modifying the existing ones.</span>
<span class="sd">    func: callable</span>
<span class="sd">        Callable that calculates the test function. It must have the following call signature</span>
<span class="sd">        ``func(y, theta, *args, **kwargs)`` (where ``y`` is the observed data or posterior</span>
<span class="sd">        predictive and ``theta`` the model parameters) even if not all the arguments are</span>
<span class="sd">        used.</span>
<span class="sd">    group: str, optional</span>
<span class="sd">        Group on which to apply the test function. Can be observed_data, posterior_predictive</span>
<span class="sd">        or both.</span>
<span class="sd">    var_names: dict group -&gt; var_names, optional</span>
<span class="sd">        Mapping from group name to the variables to be passed to func. It can be a dict of</span>
<span class="sd">        strings or lists of strings. There is also the option of using ``both`` as key,</span>
<span class="sd">        in which case, the same variables are used in observed data and posterior predictive</span>
<span class="sd">        groups</span>
<span class="sd">    pointwise: bool, optional</span>
<span class="sd">        If True, apply the test function to each observation and sample, otherwise, apply</span>
<span class="sd">        test function to each sample.</span>
<span class="sd">    out_data_shape, out_pp_shape: tuple, optional</span>
<span class="sd">        Output shape of the test function applied to the observed/posterior predictive data.</span>
<span class="sd">        If None, the default depends on the value of pointwise.</span>
<span class="sd">    out_name_data, out_name_pp: str, optional</span>
<span class="sd">        Name of the variables to add to the observed_data and posterior_predictive datasets</span>
<span class="sd">        respectively. ``out_name_pp`` can be ``None``, in which case will be taken equal to</span>
<span class="sd">        ``out_name_data``.</span>
<span class="sd">    func_args: sequence, optional</span>
<span class="sd">        Passed as is to ``func``</span>
<span class="sd">    func_kwargs: mapping, optional</span>
<span class="sd">        Passed as is to ``func``</span>
<span class="sd">    wrap_data_kwargs, wrap_pp_kwargs: mapping, optional</span>
<span class="sd">        kwargs passed to :func:`~arviz.wrap_xarray_ufunc`. By default, some suitable input_core_dims</span>
<span class="sd">        are used.</span>
<span class="sd">    inplace: bool, optional</span>
<span class="sd">        If True, add the variables inplace, otherwise, return a copy of idata with the variables</span>
<span class="sd">        added.</span>
<span class="sd">    overwrite: bool, optional</span>
<span class="sd">        Overwrite data in case ``out_name_data`` or ``out_name_pp`` are already variables in</span>
<span class="sd">        dataset. If ``None`` it will be the opposite of inplace.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idata: InferenceData</span>
<span class="sd">        Output InferenceData object. If ``inplace=True``, it is the same input object modified</span>
<span class="sd">        inplace.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    plot_bpv :  Plot Bayesian p-value for observed data and Posterior/Prior predictive.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is provided for convenience to wrap scalar or functions working on low</span>
<span class="sd">    dims to inference data object. It is not optimized to be faster nor as fast as vectorized</span>
<span class="sd">    computations.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Use ``apply_test_function`` to wrap ``numpy.min`` for illustration purposes. And plot the</span>
<span class="sd">    results.</span>

<span class="sd">    .. plot::</span>
<span class="sd">        :context: close-figs</span>

<span class="sd">        &gt;&gt;&gt; import arviz as az</span>
<span class="sd">        &gt;&gt;&gt; idata = az.load_arviz_data(&quot;centered_eight&quot;)</span>
<span class="sd">        &gt;&gt;&gt; az.apply_test_function(idata, lambda y, theta: np.min(y))</span>
<span class="sd">        &gt;&gt;&gt; T = np.asscalar(idata.observed_data.T)</span>
<span class="sd">        &gt;&gt;&gt; az.plot_posterior(idata, var_names=[&quot;T&quot;], group=&quot;posterior_predictive&quot;, ref_val=T)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">idata</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">idata</span><span class="p">)</span>

    <span class="n">valid_groups</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;observed_data&quot;</span><span class="p">,</span> <span class="s2">&quot;posterior_predictive&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_groups</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid group argument. Must be one of </span><span class="si">{</span><span class="n">valid_groups</span><span class="si">}</span><span class="s2"> not </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overwrite</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">overwrite</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">inplace</span>

    <span class="k">if</span> <span class="n">out_name_pp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_name_pp</span> <span class="o">=</span> <span class="n">out_name_data</span>

    <span class="k">if</span> <span class="n">func_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">func_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">func_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">ufunc_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ufunc_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">ufunc_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;check_shape&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">ufunc_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;ravel&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">wrap_data_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wrap_data_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">wrap_pp_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wrap_pp_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">var_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">var_names</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">both_var_names</span> <span class="o">=</span> <span class="n">var_names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">var_names</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;posterior&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">posterior</span><span class="o">.</span><span class="n">data_vars</span><span class="p">))</span>

    <span class="n">in_posterior</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">posterior</span><span class="p">[</span><span class="n">var_names</span><span class="p">[</span><span class="s2">&quot;posterior&quot;</span><span class="p">]]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_posterior</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
        <span class="n">in_posterior</span> <span class="o">=</span> <span class="n">in_posterior</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="n">groups</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;posterior_predictive&quot;</span><span class="p">,</span> <span class="s2">&quot;observed_data&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">group</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span> <span class="k">else</span> <span class="p">[</span><span class="n">group</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="n">out_group_shape</span> <span class="o">=</span> <span class="n">out_data_shape</span> <span class="k">if</span> <span class="n">grp</span> <span class="o">==</span> <span class="s2">&quot;observed_data&quot;</span> <span class="k">else</span> <span class="n">out_pp_shape</span>
        <span class="n">out_name_group</span> <span class="o">=</span> <span class="n">out_name_data</span> <span class="k">if</span> <span class="n">grp</span> <span class="o">==</span> <span class="s2">&quot;observed_data&quot;</span> <span class="k">else</span> <span class="n">out_name_pp</span>
        <span class="n">wrap_group_kwargs</span> <span class="o">=</span> <span class="n">wrap_data_kwargs</span> <span class="k">if</span> <span class="n">grp</span> <span class="o">==</span> <span class="s2">&quot;observed_data&quot;</span> <span class="k">else</span> <span class="n">wrap_pp_kwargs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">grp</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;InferenceData object must have </span><span class="si">{</span><span class="n">grp</span><span class="si">}</span><span class="s2"> group&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">out_name_group</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">grp</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Should overwrite: </span><span class="si">{</span><span class="n">out_name_group</span><span class="si">}</span><span class="s2"> variable present in group </span><span class="si">{</span><span class="n">grp</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="s2">&quot; but overwrite is False&quot;</span>
            <span class="p">)</span>
        <span class="n">var_names</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">grp</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">grp</span><span class="p">)</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span> <span class="k">if</span> <span class="n">both_var_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">both_var_names</span>
        <span class="p">)</span>
        <span class="n">in_group</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">grp</span><span class="p">)[</span><span class="n">var_names</span><span class="p">[</span><span class="n">grp</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_group</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="n">in_group</span> <span class="o">=</span> <span class="n">in_group</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">grp</span><span class="si">}</span><span class="s2">_var&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pointwise</span><span class="p">:</span>
            <span class="n">out_group_shape</span> <span class="o">=</span> <span class="n">in_group</span><span class="o">.</span><span class="n">shape</span> <span class="k">if</span> <span class="n">out_group_shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out_group_shape</span>
        <span class="k">elif</span> <span class="n">grp</span> <span class="o">==</span> <span class="s2">&quot;observed_data&quot;</span><span class="p">:</span>
            <span class="n">out_group_shape</span> <span class="o">=</span> <span class="p">()</span> <span class="k">if</span> <span class="n">out_group_shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out_group_shape</span>
        <span class="k">elif</span> <span class="n">grp</span> <span class="o">==</span> <span class="s2">&quot;posterior_predictive&quot;</span><span class="p">:</span>
            <span class="n">out_group_shape</span> <span class="o">=</span> <span class="n">in_group</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">out_group_shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out_group_shape</span>
        <span class="n">loop_dims</span> <span class="o">=</span> <span class="n">in_group</span><span class="o">.</span><span class="n">dims</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_group_shape</span><span class="p">)]</span>

        <span class="n">wrap_group_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="s2">&quot;input_core_dims&quot;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">dim</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">dims</span> <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loop_dims</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="p">[</span><span class="n">in_group</span><span class="p">,</span> <span class="n">in_posterior</span><span class="p">]</span>
            <span class="p">],</span>
        <span class="p">)</span>
        <span class="n">func_kwargs</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">out_group_shape</span><span class="p">)</span>

        <span class="n">out_group</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">grp</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out_group</span><span class="p">[</span><span class="n">out_name_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span>
                <span class="n">in_group</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">in_posterior</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">func_args</span><span class="o">=</span><span class="n">func_args</span><span class="p">,</span>
                <span class="n">func_kwargs</span><span class="o">=</span><span class="n">func_kwargs</span><span class="p">,</span>
                <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span>
                <span class="o">**</span><span class="n">wrap_group_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">excluded_dims</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">wrap_group_kwargs</span><span class="p">[</span><span class="s2">&quot;input_core_dims&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">wrap_group_kwargs</span><span class="p">[</span><span class="s2">&quot;input_core_dims&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">out_group</span><span class="p">[</span><span class="n">out_name_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">_wrap_xarray_ufunc</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span>
                <span class="o">*</span><span class="n">xr</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">in_group</span><span class="p">,</span> <span class="n">in_posterior</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">excluded_dims</span><span class="p">),</span>
                <span class="n">func_args</span><span class="o">=</span><span class="n">func_args</span><span class="p">,</span>
                <span class="n">func_kwargs</span><span class="o">=</span><span class="n">func_kwargs</span><span class="p">,</span>
                <span class="n">ufunc_kwargs</span><span class="o">=</span><span class="n">ufunc_kwargs</span><span class="p">,</span>
                <span class="o">**</span><span class="n">wrap_group_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">grp</span><span class="p">,</span> <span class="n">out_group</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span></div>
</pre></div>

              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              
          </main>
          
  


      </div>
    </div>
  
  <script src="../../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2018, ArviZ devs.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.1.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>